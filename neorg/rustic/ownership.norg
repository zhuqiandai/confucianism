@document.meta
title: ownership
description: 
authors: 
categories: rustic
created: 2024-10-09T10:13:22+0800
updated: 2024-10-10T17:21:05+0800
version: 1.1.1
@end

> full ownership semantics，on the stack, when the function call ends, Rust deallocates the stack frame.

> Box deallocation principle (almost correct): If a variable is bound to a box, when Rust deallocates the variable’s frame, then Rust deallocates the box’s heap memory.
> Box deallocation principle (fully correct): If a variable owns a box, when Rust deallocates the variable’s frame, then Rust deallocates the box’s heap memory.

所以理解 `stack frame` 至关重要包括之后的闭包

* Part 1

** Copy

   - primitive types
   - tuple of primitive types
   - struct impl `Copy trait` (every fields)

*** Copy trait

** Clone

   > The idea of `Clone` is to make it easy to spot *where heap allocation are occurring*.

*** Clone trait

** Move semantics

   > transfer ownership by assignment

@code rust 
fn main() {
    let first = String::from("Ferris");
    let full = add_suffix(first);
    println!("{full}, originally {first}"); // first is now used here
}

fn add_suffix(mut name: String) -> String {
    name.push_str(" Jr.");
    name
}
@end

   > Remember: it’s not a problem that first points to deallocated memory. It’s a problem that we tried to use first after it became invalid.

* Part 2

** Borrow semantics

   > for permission: `read` `write`; for code: concise and convenient style of programming

   > do not transfer ownership, borrow access to read, use `&` or `mut &`

*** Reference (create a reference to borrowing)

    > References are non-owning pointers, 

** Drop semantics

*** Drop trait

